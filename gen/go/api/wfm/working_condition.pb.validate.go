// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: working_condition.proto

package wfm

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateWorkingConditionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateWorkingConditionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWorkingConditionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateWorkingConditionRequestMultiError, or nil if none found.
func (m *CreateWorkingConditionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWorkingConditionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateWorkingConditionRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateWorkingConditionRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateWorkingConditionRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateWorkingConditionRequestMultiError(errors)
	}

	return nil
}

// CreateWorkingConditionRequestMultiError is an error wrapping multiple
// validation errors returned by CreateWorkingConditionRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateWorkingConditionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWorkingConditionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWorkingConditionRequestMultiError) AllErrors() []error { return m }

// CreateWorkingConditionRequestValidationError is the validation error
// returned by CreateWorkingConditionRequest.Validate if the designated
// constraints aren't met.
type CreateWorkingConditionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWorkingConditionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWorkingConditionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWorkingConditionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWorkingConditionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWorkingConditionRequestValidationError) ErrorName() string {
	return "CreateWorkingConditionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWorkingConditionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWorkingConditionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWorkingConditionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWorkingConditionRequestValidationError{}

// Validate checks the field values on CreateWorkingConditionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateWorkingConditionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWorkingConditionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateWorkingConditionResponseMultiError, or nil if none found.
func (m *CreateWorkingConditionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWorkingConditionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateWorkingConditionResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateWorkingConditionResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateWorkingConditionResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateWorkingConditionResponseMultiError(errors)
	}

	return nil
}

// CreateWorkingConditionResponseMultiError is an error wrapping multiple
// validation errors returned by CreateWorkingConditionResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateWorkingConditionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWorkingConditionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWorkingConditionResponseMultiError) AllErrors() []error { return m }

// CreateWorkingConditionResponseValidationError is the validation error
// returned by CreateWorkingConditionResponse.Validate if the designated
// constraints aren't met.
type CreateWorkingConditionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWorkingConditionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWorkingConditionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWorkingConditionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWorkingConditionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWorkingConditionResponseValidationError) ErrorName() string {
	return "CreateWorkingConditionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWorkingConditionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWorkingConditionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWorkingConditionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWorkingConditionResponseValidationError{}

// Validate checks the field values on ReadWorkingConditionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadWorkingConditionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadWorkingConditionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadWorkingConditionRequestMultiError, or nil if none found.
func (m *ReadWorkingConditionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadWorkingConditionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ReadWorkingConditionRequestMultiError(errors)
	}

	return nil
}

// ReadWorkingConditionRequestMultiError is an error wrapping multiple
// validation errors returned by ReadWorkingConditionRequest.ValidateAll() if
// the designated constraints aren't met.
type ReadWorkingConditionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadWorkingConditionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadWorkingConditionRequestMultiError) AllErrors() []error { return m }

// ReadWorkingConditionRequestValidationError is the validation error returned
// by ReadWorkingConditionRequest.Validate if the designated constraints
// aren't met.
type ReadWorkingConditionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadWorkingConditionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadWorkingConditionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadWorkingConditionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadWorkingConditionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadWorkingConditionRequestValidationError) ErrorName() string {
	return "ReadWorkingConditionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadWorkingConditionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadWorkingConditionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadWorkingConditionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadWorkingConditionRequestValidationError{}

// Validate checks the field values on ReadWorkingConditionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadWorkingConditionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadWorkingConditionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadWorkingConditionResponseMultiError, or nil if none found.
func (m *ReadWorkingConditionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadWorkingConditionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadWorkingConditionResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadWorkingConditionResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadWorkingConditionResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadWorkingConditionResponseMultiError(errors)
	}

	return nil
}

// ReadWorkingConditionResponseMultiError is an error wrapping multiple
// validation errors returned by ReadWorkingConditionResponse.ValidateAll() if
// the designated constraints aren't met.
type ReadWorkingConditionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadWorkingConditionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadWorkingConditionResponseMultiError) AllErrors() []error { return m }

// ReadWorkingConditionResponseValidationError is the validation error returned
// by ReadWorkingConditionResponse.Validate if the designated constraints
// aren't met.
type ReadWorkingConditionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadWorkingConditionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadWorkingConditionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadWorkingConditionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadWorkingConditionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadWorkingConditionResponseValidationError) ErrorName() string {
	return "ReadWorkingConditionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadWorkingConditionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadWorkingConditionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadWorkingConditionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadWorkingConditionResponseValidationError{}

// Validate checks the field values on SearchWorkingConditionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchWorkingConditionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchWorkingConditionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SearchWorkingConditionRequestMultiError, or nil if none found.
func (m *SearchWorkingConditionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchWorkingConditionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.Size != nil {
		// no validation rules for Size
	}

	if m.Q != nil {
		// no validation rules for Q
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if len(errors) > 0 {
		return SearchWorkingConditionRequestMultiError(errors)
	}

	return nil
}

// SearchWorkingConditionRequestMultiError is an error wrapping multiple
// validation errors returned by SearchWorkingConditionRequest.ValidateAll()
// if the designated constraints aren't met.
type SearchWorkingConditionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchWorkingConditionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchWorkingConditionRequestMultiError) AllErrors() []error { return m }

// SearchWorkingConditionRequestValidationError is the validation error
// returned by SearchWorkingConditionRequest.Validate if the designated
// constraints aren't met.
type SearchWorkingConditionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchWorkingConditionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchWorkingConditionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchWorkingConditionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchWorkingConditionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchWorkingConditionRequestValidationError) ErrorName() string {
	return "SearchWorkingConditionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchWorkingConditionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchWorkingConditionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchWorkingConditionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchWorkingConditionRequestValidationError{}

// Validate checks the field values on SearchWorkingConditionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchWorkingConditionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchWorkingConditionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SearchWorkingConditionResponseMultiError, or nil if none found.
func (m *SearchWorkingConditionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchWorkingConditionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchWorkingConditionResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchWorkingConditionResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchWorkingConditionResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Next

	if len(errors) > 0 {
		return SearchWorkingConditionResponseMultiError(errors)
	}

	return nil
}

// SearchWorkingConditionResponseMultiError is an error wrapping multiple
// validation errors returned by SearchWorkingConditionResponse.ValidateAll()
// if the designated constraints aren't met.
type SearchWorkingConditionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchWorkingConditionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchWorkingConditionResponseMultiError) AllErrors() []error { return m }

// SearchWorkingConditionResponseValidationError is the validation error
// returned by SearchWorkingConditionResponse.Validate if the designated
// constraints aren't met.
type SearchWorkingConditionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchWorkingConditionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchWorkingConditionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchWorkingConditionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchWorkingConditionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchWorkingConditionResponseValidationError) ErrorName() string {
	return "SearchWorkingConditionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SearchWorkingConditionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchWorkingConditionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchWorkingConditionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchWorkingConditionResponseValidationError{}

// Validate checks the field values on UpdateWorkingConditionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateWorkingConditionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateWorkingConditionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateWorkingConditionRequestMultiError, or nil if none found.
func (m *UpdateWorkingConditionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateWorkingConditionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateWorkingConditionRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateWorkingConditionRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateWorkingConditionRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateWorkingConditionRequestMultiError(errors)
	}

	return nil
}

// UpdateWorkingConditionRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateWorkingConditionRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateWorkingConditionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWorkingConditionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWorkingConditionRequestMultiError) AllErrors() []error { return m }

// UpdateWorkingConditionRequestValidationError is the validation error
// returned by UpdateWorkingConditionRequest.Validate if the designated
// constraints aren't met.
type UpdateWorkingConditionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWorkingConditionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWorkingConditionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWorkingConditionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWorkingConditionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWorkingConditionRequestValidationError) ErrorName() string {
	return "UpdateWorkingConditionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWorkingConditionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWorkingConditionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWorkingConditionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWorkingConditionRequestValidationError{}

// Validate checks the field values on UpdateWorkingConditionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateWorkingConditionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateWorkingConditionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateWorkingConditionResponseMultiError, or nil if none found.
func (m *UpdateWorkingConditionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateWorkingConditionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateWorkingConditionResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateWorkingConditionResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateWorkingConditionResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateWorkingConditionResponseMultiError(errors)
	}

	return nil
}

// UpdateWorkingConditionResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateWorkingConditionResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateWorkingConditionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWorkingConditionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWorkingConditionResponseMultiError) AllErrors() []error { return m }

// UpdateWorkingConditionResponseValidationError is the validation error
// returned by UpdateWorkingConditionResponse.Validate if the designated
// constraints aren't met.
type UpdateWorkingConditionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWorkingConditionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWorkingConditionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWorkingConditionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWorkingConditionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWorkingConditionResponseValidationError) ErrorName() string {
	return "UpdateWorkingConditionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWorkingConditionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWorkingConditionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWorkingConditionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWorkingConditionResponseValidationError{}

// Validate checks the field values on DeleteWorkingConditionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteWorkingConditionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteWorkingConditionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteWorkingConditionRequestMultiError, or nil if none found.
func (m *DeleteWorkingConditionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteWorkingConditionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteWorkingConditionRequestMultiError(errors)
	}

	return nil
}

// DeleteWorkingConditionRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteWorkingConditionRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteWorkingConditionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteWorkingConditionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteWorkingConditionRequestMultiError) AllErrors() []error { return m }

// DeleteWorkingConditionRequestValidationError is the validation error
// returned by DeleteWorkingConditionRequest.Validate if the designated
// constraints aren't met.
type DeleteWorkingConditionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteWorkingConditionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteWorkingConditionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteWorkingConditionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteWorkingConditionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteWorkingConditionRequestValidationError) ErrorName() string {
	return "DeleteWorkingConditionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteWorkingConditionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteWorkingConditionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteWorkingConditionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteWorkingConditionRequestValidationError{}

// Validate checks the field values on DeleteWorkingConditionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteWorkingConditionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteWorkingConditionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteWorkingConditionResponseMultiError, or nil if none found.
func (m *DeleteWorkingConditionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteWorkingConditionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteWorkingConditionResponseMultiError(errors)
	}

	return nil
}

// DeleteWorkingConditionResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteWorkingConditionResponse.ValidateAll()
// if the designated constraints aren't met.
type DeleteWorkingConditionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteWorkingConditionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteWorkingConditionResponseMultiError) AllErrors() []error { return m }

// DeleteWorkingConditionResponseValidationError is the validation error
// returned by DeleteWorkingConditionResponse.Validate if the designated
// constraints aren't met.
type DeleteWorkingConditionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteWorkingConditionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteWorkingConditionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteWorkingConditionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteWorkingConditionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteWorkingConditionResponseValidationError) ErrorName() string {
	return "DeleteWorkingConditionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteWorkingConditionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteWorkingConditionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteWorkingConditionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteWorkingConditionResponseValidationError{}

// Validate checks the field values on WorkingCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WorkingCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkingCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkingConditionMultiError, or nil if none found.
func (m *WorkingCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkingCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DomainId

	// no validation rules for CreatedAt

	if all {
		switch v := interface{}(m.GetCreatedBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkingConditionValidationError{
					field:  "CreatedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkingConditionValidationError{
					field:  "CreatedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkingConditionValidationError{
				field:  "CreatedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedAt

	if all {
		switch v := interface{}(m.GetUpdatedBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkingConditionValidationError{
					field:  "UpdatedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkingConditionValidationError{
					field:  "UpdatedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkingConditionValidationError{
				field:  "UpdatedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetPauseTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkingConditionValidationError{
					field:  "PauseTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkingConditionValidationError{
					field:  "PauseTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPauseTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkingConditionValidationError{
				field:  "PauseTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.WorkdayHours != nil {
		// no validation rules for WorkdayHours
	}

	if m.WorkdaysPerMonth != nil {
		// no validation rules for WorkdaysPerMonth
	}

	if m.Vacation != nil {
		// no validation rules for Vacation
	}

	if m.SickLeaves != nil {
		// no validation rules for SickLeaves
	}

	if m.DaysOff != nil {
		// no validation rules for DaysOff
	}

	if m.PauseDuration != nil {
		// no validation rules for PauseDuration
	}

	if m.ShiftTemplate != nil {

		if all {
			switch v := interface{}(m.GetShiftTemplate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkingConditionValidationError{
						field:  "ShiftTemplate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkingConditionValidationError{
						field:  "ShiftTemplate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetShiftTemplate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkingConditionValidationError{
					field:  "ShiftTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WorkingConditionMultiError(errors)
	}

	return nil
}

// WorkingConditionMultiError is an error wrapping multiple validation errors
// returned by WorkingCondition.ValidateAll() if the designated constraints
// aren't met.
type WorkingConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkingConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkingConditionMultiError) AllErrors() []error { return m }

// WorkingConditionValidationError is the validation error returned by
// WorkingCondition.Validate if the designated constraints aren't met.
type WorkingConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkingConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkingConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkingConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkingConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkingConditionValidationError) ErrorName() string { return "WorkingConditionValidationError" }

// Error satisfies the builtin error interface
func (e WorkingConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkingCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkingConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkingConditionValidationError{}
