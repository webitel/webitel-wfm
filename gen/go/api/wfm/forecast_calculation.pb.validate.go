// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: forecast_calculation.proto

package wfm

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateForecastCalculationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateForecastCalculationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateForecastCalculationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateForecastCalculationRequestMultiError, or nil if none found.
func (m *CreateForecastCalculationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateForecastCalculationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateForecastCalculationRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateForecastCalculationRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateForecastCalculationRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateForecastCalculationRequestMultiError(errors)
	}

	return nil
}

// CreateForecastCalculationRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateForecastCalculationRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateForecastCalculationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateForecastCalculationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateForecastCalculationRequestMultiError) AllErrors() []error { return m }

// CreateForecastCalculationRequestValidationError is the validation error
// returned by CreateForecastCalculationRequest.Validate if the designated
// constraints aren't met.
type CreateForecastCalculationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateForecastCalculationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateForecastCalculationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateForecastCalculationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateForecastCalculationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateForecastCalculationRequestValidationError) ErrorName() string {
	return "CreateForecastCalculationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateForecastCalculationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateForecastCalculationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateForecastCalculationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateForecastCalculationRequestValidationError{}

// Validate checks the field values on CreateForecastCalculationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateForecastCalculationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateForecastCalculationResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateForecastCalculationResponseMultiError, or nil if none found.
func (m *CreateForecastCalculationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateForecastCalculationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateForecastCalculationResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateForecastCalculationResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateForecastCalculationResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateForecastCalculationResponseMultiError(errors)
	}

	return nil
}

// CreateForecastCalculationResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateForecastCalculationResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateForecastCalculationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateForecastCalculationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateForecastCalculationResponseMultiError) AllErrors() []error { return m }

// CreateForecastCalculationResponseValidationError is the validation error
// returned by CreateForecastCalculationResponse.Validate if the designated
// constraints aren't met.
type CreateForecastCalculationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateForecastCalculationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateForecastCalculationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateForecastCalculationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateForecastCalculationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateForecastCalculationResponseValidationError) ErrorName() string {
	return "CreateForecastCalculationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateForecastCalculationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateForecastCalculationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateForecastCalculationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateForecastCalculationResponseValidationError{}

// Validate checks the field values on ReadForecastCalculationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadForecastCalculationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadForecastCalculationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReadForecastCalculationRequestMultiError, or nil if none found.
func (m *ReadForecastCalculationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadForecastCalculationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ReadForecastCalculationRequestMultiError(errors)
	}

	return nil
}

// ReadForecastCalculationRequestMultiError is an error wrapping multiple
// validation errors returned by ReadForecastCalculationRequest.ValidateAll()
// if the designated constraints aren't met.
type ReadForecastCalculationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadForecastCalculationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadForecastCalculationRequestMultiError) AllErrors() []error { return m }

// ReadForecastCalculationRequestValidationError is the validation error
// returned by ReadForecastCalculationRequest.Validate if the designated
// constraints aren't met.
type ReadForecastCalculationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadForecastCalculationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadForecastCalculationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadForecastCalculationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadForecastCalculationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadForecastCalculationRequestValidationError) ErrorName() string {
	return "ReadForecastCalculationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadForecastCalculationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadForecastCalculationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadForecastCalculationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadForecastCalculationRequestValidationError{}

// Validate checks the field values on ReadForecastCalculationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadForecastCalculationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadForecastCalculationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReadForecastCalculationResponseMultiError, or nil if none found.
func (m *ReadForecastCalculationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadForecastCalculationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadForecastCalculationResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadForecastCalculationResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadForecastCalculationResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadForecastCalculationResponseMultiError(errors)
	}

	return nil
}

// ReadForecastCalculationResponseMultiError is an error wrapping multiple
// validation errors returned by ReadForecastCalculationResponse.ValidateAll()
// if the designated constraints aren't met.
type ReadForecastCalculationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadForecastCalculationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadForecastCalculationResponseMultiError) AllErrors() []error { return m }

// ReadForecastCalculationResponseValidationError is the validation error
// returned by ReadForecastCalculationResponse.Validate if the designated
// constraints aren't met.
type ReadForecastCalculationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadForecastCalculationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadForecastCalculationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadForecastCalculationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadForecastCalculationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadForecastCalculationResponseValidationError) ErrorName() string {
	return "ReadForecastCalculationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadForecastCalculationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadForecastCalculationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadForecastCalculationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadForecastCalculationResponseValidationError{}

// Validate checks the field values on SearchForecastCalculationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SearchForecastCalculationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchForecastCalculationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SearchForecastCalculationRequestMultiError, or nil if none found.
func (m *SearchForecastCalculationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchForecastCalculationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Q != nil {
		// no validation rules for Q
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.Size != nil {
		// no validation rules for Size
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if len(errors) > 0 {
		return SearchForecastCalculationRequestMultiError(errors)
	}

	return nil
}

// SearchForecastCalculationRequestMultiError is an error wrapping multiple
// validation errors returned by
// SearchForecastCalculationRequest.ValidateAll() if the designated
// constraints aren't met.
type SearchForecastCalculationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchForecastCalculationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchForecastCalculationRequestMultiError) AllErrors() []error { return m }

// SearchForecastCalculationRequestValidationError is the validation error
// returned by SearchForecastCalculationRequest.Validate if the designated
// constraints aren't met.
type SearchForecastCalculationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchForecastCalculationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchForecastCalculationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchForecastCalculationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchForecastCalculationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchForecastCalculationRequestValidationError) ErrorName() string {
	return "SearchForecastCalculationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchForecastCalculationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchForecastCalculationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchForecastCalculationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchForecastCalculationRequestValidationError{}

// Validate checks the field values on SearchForecastCalculationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SearchForecastCalculationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchForecastCalculationResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SearchForecastCalculationResponseMultiError, or nil if none found.
func (m *SearchForecastCalculationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchForecastCalculationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchForecastCalculationResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchForecastCalculationResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchForecastCalculationResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Next

	if len(errors) > 0 {
		return SearchForecastCalculationResponseMultiError(errors)
	}

	return nil
}

// SearchForecastCalculationResponseMultiError is an error wrapping multiple
// validation errors returned by
// SearchForecastCalculationResponse.ValidateAll() if the designated
// constraints aren't met.
type SearchForecastCalculationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchForecastCalculationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchForecastCalculationResponseMultiError) AllErrors() []error { return m }

// SearchForecastCalculationResponseValidationError is the validation error
// returned by SearchForecastCalculationResponse.Validate if the designated
// constraints aren't met.
type SearchForecastCalculationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchForecastCalculationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchForecastCalculationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchForecastCalculationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchForecastCalculationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchForecastCalculationResponseValidationError) ErrorName() string {
	return "SearchForecastCalculationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SearchForecastCalculationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchForecastCalculationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchForecastCalculationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchForecastCalculationResponseValidationError{}

// Validate checks the field values on UpdateForecastCalculationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateForecastCalculationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateForecastCalculationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateForecastCalculationRequestMultiError, or nil if none found.
func (m *UpdateForecastCalculationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateForecastCalculationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateForecastCalculationRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateForecastCalculationRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateForecastCalculationRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateForecastCalculationRequestMultiError(errors)
	}

	return nil
}

// UpdateForecastCalculationRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateForecastCalculationRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateForecastCalculationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateForecastCalculationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateForecastCalculationRequestMultiError) AllErrors() []error { return m }

// UpdateForecastCalculationRequestValidationError is the validation error
// returned by UpdateForecastCalculationRequest.Validate if the designated
// constraints aren't met.
type UpdateForecastCalculationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateForecastCalculationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateForecastCalculationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateForecastCalculationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateForecastCalculationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateForecastCalculationRequestValidationError) ErrorName() string {
	return "UpdateForecastCalculationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateForecastCalculationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateForecastCalculationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateForecastCalculationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateForecastCalculationRequestValidationError{}

// Validate checks the field values on UpdateForecastCalculationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateForecastCalculationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateForecastCalculationResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateForecastCalculationResponseMultiError, or nil if none found.
func (m *UpdateForecastCalculationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateForecastCalculationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateForecastCalculationResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateForecastCalculationResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateForecastCalculationResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateForecastCalculationResponseMultiError(errors)
	}

	return nil
}

// UpdateForecastCalculationResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateForecastCalculationResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateForecastCalculationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateForecastCalculationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateForecastCalculationResponseMultiError) AllErrors() []error { return m }

// UpdateForecastCalculationResponseValidationError is the validation error
// returned by UpdateForecastCalculationResponse.Validate if the designated
// constraints aren't met.
type UpdateForecastCalculationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateForecastCalculationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateForecastCalculationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateForecastCalculationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateForecastCalculationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateForecastCalculationResponseValidationError) ErrorName() string {
	return "UpdateForecastCalculationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateForecastCalculationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateForecastCalculationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateForecastCalculationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateForecastCalculationResponseValidationError{}

// Validate checks the field values on DeleteForecastCalculationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteForecastCalculationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteForecastCalculationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteForecastCalculationRequestMultiError, or nil if none found.
func (m *DeleteForecastCalculationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteForecastCalculationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteForecastCalculationRequestMultiError(errors)
	}

	return nil
}

// DeleteForecastCalculationRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteForecastCalculationRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteForecastCalculationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteForecastCalculationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteForecastCalculationRequestMultiError) AllErrors() []error { return m }

// DeleteForecastCalculationRequestValidationError is the validation error
// returned by DeleteForecastCalculationRequest.Validate if the designated
// constraints aren't met.
type DeleteForecastCalculationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteForecastCalculationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteForecastCalculationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteForecastCalculationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteForecastCalculationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteForecastCalculationRequestValidationError) ErrorName() string {
	return "DeleteForecastCalculationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteForecastCalculationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteForecastCalculationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteForecastCalculationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteForecastCalculationRequestValidationError{}

// Validate checks the field values on DeleteForecastCalculationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteForecastCalculationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteForecastCalculationResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteForecastCalculationResponseMultiError, or nil if none found.
func (m *DeleteForecastCalculationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteForecastCalculationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteForecastCalculationResponseMultiError(errors)
	}

	return nil
}

// DeleteForecastCalculationResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteForecastCalculationResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteForecastCalculationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteForecastCalculationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteForecastCalculationResponseMultiError) AllErrors() []error { return m }

// DeleteForecastCalculationResponseValidationError is the validation error
// returned by DeleteForecastCalculationResponse.Validate if the designated
// constraints aren't met.
type DeleteForecastCalculationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteForecastCalculationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteForecastCalculationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteForecastCalculationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteForecastCalculationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteForecastCalculationResponseValidationError) ErrorName() string {
	return "DeleteForecastCalculationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteForecastCalculationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteForecastCalculationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteForecastCalculationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteForecastCalculationResponseValidationError{}

// Validate checks the field values on ExecuteForecastCalculationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ExecuteForecastCalculationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteForecastCalculationRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExecuteForecastCalculationRequestMultiError, or nil if none found.
func (m *ExecuteForecastCalculationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteForecastCalculationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TeamId

	if all {
		switch v := interface{}(m.GetForecastData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteForecastCalculationRequestValidationError{
					field:  "ForecastData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteForecastCalculationRequestValidationError{
					field:  "ForecastData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetForecastData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteForecastCalculationRequestValidationError{
				field:  "ForecastData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExecuteForecastCalculationRequestMultiError(errors)
	}

	return nil
}

// ExecuteForecastCalculationRequestMultiError is an error wrapping multiple
// validation errors returned by
// ExecuteForecastCalculationRequest.ValidateAll() if the designated
// constraints aren't met.
type ExecuteForecastCalculationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteForecastCalculationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteForecastCalculationRequestMultiError) AllErrors() []error { return m }

// ExecuteForecastCalculationRequestValidationError is the validation error
// returned by ExecuteForecastCalculationRequest.Validate if the designated
// constraints aren't met.
type ExecuteForecastCalculationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteForecastCalculationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteForecastCalculationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteForecastCalculationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteForecastCalculationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteForecastCalculationRequestValidationError) ErrorName() string {
	return "ExecuteForecastCalculationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteForecastCalculationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteForecastCalculationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteForecastCalculationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteForecastCalculationRequestValidationError{}

// Validate checks the field values on ExecuteForecastCalculationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ExecuteForecastCalculationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteForecastCalculationResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExecuteForecastCalculationResponseMultiError, or nil if none found.
func (m *ExecuteForecastCalculationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteForecastCalculationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteForecastCalculationResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteForecastCalculationResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteForecastCalculationResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecuteForecastCalculationResponseMultiError(errors)
	}

	return nil
}

// ExecuteForecastCalculationResponseMultiError is an error wrapping multiple
// validation errors returned by
// ExecuteForecastCalculationResponse.ValidateAll() if the designated
// constraints aren't met.
type ExecuteForecastCalculationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteForecastCalculationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteForecastCalculationResponseMultiError) AllErrors() []error { return m }

// ExecuteForecastCalculationResponseValidationError is the validation error
// returned by ExecuteForecastCalculationResponse.Validate if the designated
// constraints aren't met.
type ExecuteForecastCalculationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteForecastCalculationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteForecastCalculationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteForecastCalculationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteForecastCalculationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteForecastCalculationResponseValidationError) ErrorName() string {
	return "ExecuteForecastCalculationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteForecastCalculationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteForecastCalculationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteForecastCalculationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteForecastCalculationResponseValidationError{}

// Validate checks the field values on ForecastCalculation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ForecastCalculation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ForecastCalculation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ForecastCalculationMultiError, or nil if none found.
func (m *ForecastCalculation) ValidateAll() error {
	return m.validate(true)
}

func (m *ForecastCalculation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DomainId

	// no validation rules for CreatedAt

	if all {
		switch v := interface{}(m.GetCreatedBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ForecastCalculationValidationError{
					field:  "CreatedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ForecastCalculationValidationError{
					field:  "CreatedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ForecastCalculationValidationError{
				field:  "CreatedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedAt

	if all {
		switch v := interface{}(m.GetUpdatedBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ForecastCalculationValidationError{
					field:  "UpdatedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ForecastCalculationValidationError{
					field:  "UpdatedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ForecastCalculationValidationError{
				field:  "UpdatedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for Procedure

	if m.Description != nil {
		// no validation rules for Description
	}

	if len(errors) > 0 {
		return ForecastCalculationMultiError(errors)
	}

	return nil
}

// ForecastCalculationMultiError is an error wrapping multiple validation
// errors returned by ForecastCalculation.ValidateAll() if the designated
// constraints aren't met.
type ForecastCalculationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForecastCalculationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForecastCalculationMultiError) AllErrors() []error { return m }

// ForecastCalculationValidationError is the validation error returned by
// ForecastCalculation.Validate if the designated constraints aren't met.
type ForecastCalculationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForecastCalculationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForecastCalculationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForecastCalculationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForecastCalculationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForecastCalculationValidationError) ErrorName() string {
	return "ForecastCalculationValidationError"
}

// Error satisfies the builtin error interface
func (e ForecastCalculationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForecastCalculation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForecastCalculationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForecastCalculationValidationError{}

// Validate checks the field values on
// ExecuteForecastCalculationResponse_Forecast with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecuteForecastCalculationResponse_Forecast) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExecuteForecastCalculationResponse_Forecast with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ExecuteForecastCalculationResponse_ForecastMultiError, or nil if none found.
func (m *ExecuteForecastCalculationResponse_Forecast) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteForecastCalculationResponse_Forecast) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Timestamp

	// no validation rules for Agents

	if len(errors) > 0 {
		return ExecuteForecastCalculationResponse_ForecastMultiError(errors)
	}

	return nil
}

// ExecuteForecastCalculationResponse_ForecastMultiError is an error wrapping
// multiple validation errors returned by
// ExecuteForecastCalculationResponse_Forecast.ValidateAll() if the designated
// constraints aren't met.
type ExecuteForecastCalculationResponse_ForecastMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteForecastCalculationResponse_ForecastMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteForecastCalculationResponse_ForecastMultiError) AllErrors() []error { return m }

// ExecuteForecastCalculationResponse_ForecastValidationError is the validation
// error returned by ExecuteForecastCalculationResponse_Forecast.Validate if
// the designated constraints aren't met.
type ExecuteForecastCalculationResponse_ForecastValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteForecastCalculationResponse_ForecastValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteForecastCalculationResponse_ForecastValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteForecastCalculationResponse_ForecastValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteForecastCalculationResponse_ForecastValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteForecastCalculationResponse_ForecastValidationError) ErrorName() string {
	return "ExecuteForecastCalculationResponse_ForecastValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteForecastCalculationResponse_ForecastValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteForecastCalculationResponse_Forecast.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteForecastCalculationResponse_ForecastValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteForecastCalculationResponse_ForecastValidationError{}
