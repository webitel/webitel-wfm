// Code generated by mockery v2.50.0. DO NOT EDIT.

package service

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	model "github.com/webitel/webitel-wfm/internal/model"
)

// MockWorkingScheduleManager is an autogenerated mock type for the WorkingScheduleManager type
type MockWorkingScheduleManager struct {
	mock.Mock
}

type MockWorkingScheduleManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWorkingScheduleManager) EXPECT() *MockWorkingScheduleManager_Expecter {
	return &MockWorkingScheduleManager_Expecter{mock: &_m.Mock}
}

// CreateWorkingSchedule provides a mock function with given fields: ctx, user, in
func (_m *MockWorkingScheduleManager) CreateWorkingSchedule(ctx context.Context, user *model.SignedInUser, in *model.WorkingSchedule) (*model.WorkingSchedule, error) {
	ret := _m.Called(ctx, user, in)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkingSchedule")
	}

	var r0 *model.WorkingSchedule
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, *model.WorkingSchedule) (*model.WorkingSchedule, error)); ok {
		return rf(ctx, user, in)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, *model.WorkingSchedule) *model.WorkingSchedule); ok {
		r0 = rf(ctx, user, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.WorkingSchedule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.SignedInUser, *model.WorkingSchedule) error); ok {
		r1 = rf(ctx, user, in)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWorkingScheduleManager_CreateWorkingSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkingSchedule'
type MockWorkingScheduleManager_CreateWorkingSchedule_Call struct {
	*mock.Call
}

// CreateWorkingSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.SignedInUser
//   - in *model.WorkingSchedule
func (_e *MockWorkingScheduleManager_Expecter) CreateWorkingSchedule(ctx interface{}, user interface{}, in interface{}) *MockWorkingScheduleManager_CreateWorkingSchedule_Call {
	return &MockWorkingScheduleManager_CreateWorkingSchedule_Call{Call: _e.mock.On("CreateWorkingSchedule", ctx, user, in)}
}

func (_c *MockWorkingScheduleManager_CreateWorkingSchedule_Call) Run(run func(ctx context.Context, user *model.SignedInUser, in *model.WorkingSchedule)) *MockWorkingScheduleManager_CreateWorkingSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.SignedInUser), args[2].(*model.WorkingSchedule))
	})
	return _c
}

func (_c *MockWorkingScheduleManager_CreateWorkingSchedule_Call) Return(_a0 *model.WorkingSchedule, _a1 error) *MockWorkingScheduleManager_CreateWorkingSchedule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWorkingScheduleManager_CreateWorkingSchedule_Call) RunAndReturn(run func(context.Context, *model.SignedInUser, *model.WorkingSchedule) (*model.WorkingSchedule, error)) *MockWorkingScheduleManager_CreateWorkingSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWorkingSchedule provides a mock function with given fields: ctx, user, id
func (_m *MockWorkingScheduleManager) DeleteWorkingSchedule(ctx context.Context, user *model.SignedInUser, id int64) (int64, error) {
	ret := _m.Called(ctx, user, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkingSchedule")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, int64) (int64, error)); ok {
		return rf(ctx, user, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, int64) int64); ok {
		r0 = rf(ctx, user, id)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.SignedInUser, int64) error); ok {
		r1 = rf(ctx, user, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWorkingScheduleManager_DeleteWorkingSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWorkingSchedule'
type MockWorkingScheduleManager_DeleteWorkingSchedule_Call struct {
	*mock.Call
}

// DeleteWorkingSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.SignedInUser
//   - id int64
func (_e *MockWorkingScheduleManager_Expecter) DeleteWorkingSchedule(ctx interface{}, user interface{}, id interface{}) *MockWorkingScheduleManager_DeleteWorkingSchedule_Call {
	return &MockWorkingScheduleManager_DeleteWorkingSchedule_Call{Call: _e.mock.On("DeleteWorkingSchedule", ctx, user, id)}
}

func (_c *MockWorkingScheduleManager_DeleteWorkingSchedule_Call) Run(run func(ctx context.Context, user *model.SignedInUser, id int64)) *MockWorkingScheduleManager_DeleteWorkingSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.SignedInUser), args[2].(int64))
	})
	return _c
}

func (_c *MockWorkingScheduleManager_DeleteWorkingSchedule_Call) Return(_a0 int64, _a1 error) *MockWorkingScheduleManager_DeleteWorkingSchedule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWorkingScheduleManager_DeleteWorkingSchedule_Call) RunAndReturn(run func(context.Context, *model.SignedInUser, int64) (int64, error)) *MockWorkingScheduleManager_DeleteWorkingSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// ReadWorkingSchedule provides a mock function with given fields: ctx, user, search
func (_m *MockWorkingScheduleManager) ReadWorkingSchedule(ctx context.Context, user *model.SignedInUser, search *model.SearchItem) (*model.WorkingSchedule, error) {
	ret := _m.Called(ctx, user, search)

	if len(ret) == 0 {
		panic("no return value specified for ReadWorkingSchedule")
	}

	var r0 *model.WorkingSchedule
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, *model.SearchItem) (*model.WorkingSchedule, error)); ok {
		return rf(ctx, user, search)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, *model.SearchItem) *model.WorkingSchedule); ok {
		r0 = rf(ctx, user, search)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.WorkingSchedule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.SignedInUser, *model.SearchItem) error); ok {
		r1 = rf(ctx, user, search)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWorkingScheduleManager_ReadWorkingSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadWorkingSchedule'
type MockWorkingScheduleManager_ReadWorkingSchedule_Call struct {
	*mock.Call
}

// ReadWorkingSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.SignedInUser
//   - search *model.SearchItem
func (_e *MockWorkingScheduleManager_Expecter) ReadWorkingSchedule(ctx interface{}, user interface{}, search interface{}) *MockWorkingScheduleManager_ReadWorkingSchedule_Call {
	return &MockWorkingScheduleManager_ReadWorkingSchedule_Call{Call: _e.mock.On("ReadWorkingSchedule", ctx, user, search)}
}

func (_c *MockWorkingScheduleManager_ReadWorkingSchedule_Call) Run(run func(ctx context.Context, user *model.SignedInUser, search *model.SearchItem)) *MockWorkingScheduleManager_ReadWorkingSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.SignedInUser), args[2].(*model.SearchItem))
	})
	return _c
}

func (_c *MockWorkingScheduleManager_ReadWorkingSchedule_Call) Return(_a0 *model.WorkingSchedule, _a1 error) *MockWorkingScheduleManager_ReadWorkingSchedule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWorkingScheduleManager_ReadWorkingSchedule_Call) RunAndReturn(run func(context.Context, *model.SignedInUser, *model.SearchItem) (*model.WorkingSchedule, error)) *MockWorkingScheduleManager_ReadWorkingSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// ReadWorkingScheduleForecast provides a mock function with given fields: ctx, user, id, date
func (_m *MockWorkingScheduleManager) ReadWorkingScheduleForecast(ctx context.Context, user *model.SignedInUser, id int64, date *model.FilterBetween) ([]*model.ForecastCalculationResult, error) {
	ret := _m.Called(ctx, user, id, date)

	if len(ret) == 0 {
		panic("no return value specified for ReadWorkingScheduleForecast")
	}

	var r0 []*model.ForecastCalculationResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, int64, *model.FilterBetween) ([]*model.ForecastCalculationResult, error)); ok {
		return rf(ctx, user, id, date)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, int64, *model.FilterBetween) []*model.ForecastCalculationResult); ok {
		r0 = rf(ctx, user, id, date)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.ForecastCalculationResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.SignedInUser, int64, *model.FilterBetween) error); ok {
		r1 = rf(ctx, user, id, date)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWorkingScheduleManager_ReadWorkingScheduleForecast_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadWorkingScheduleForecast'
type MockWorkingScheduleManager_ReadWorkingScheduleForecast_Call struct {
	*mock.Call
}

// ReadWorkingScheduleForecast is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.SignedInUser
//   - id int64
//   - date *model.FilterBetween
func (_e *MockWorkingScheduleManager_Expecter) ReadWorkingScheduleForecast(ctx interface{}, user interface{}, id interface{}, date interface{}) *MockWorkingScheduleManager_ReadWorkingScheduleForecast_Call {
	return &MockWorkingScheduleManager_ReadWorkingScheduleForecast_Call{Call: _e.mock.On("ReadWorkingScheduleForecast", ctx, user, id, date)}
}

func (_c *MockWorkingScheduleManager_ReadWorkingScheduleForecast_Call) Run(run func(ctx context.Context, user *model.SignedInUser, id int64, date *model.FilterBetween)) *MockWorkingScheduleManager_ReadWorkingScheduleForecast_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.SignedInUser), args[2].(int64), args[3].(*model.FilterBetween))
	})
	return _c
}

func (_c *MockWorkingScheduleManager_ReadWorkingScheduleForecast_Call) Return(_a0 []*model.ForecastCalculationResult, _a1 error) *MockWorkingScheduleManager_ReadWorkingScheduleForecast_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWorkingScheduleManager_ReadWorkingScheduleForecast_Call) RunAndReturn(run func(context.Context, *model.SignedInUser, int64, *model.FilterBetween) ([]*model.ForecastCalculationResult, error)) *MockWorkingScheduleManager_ReadWorkingScheduleForecast_Call {
	_c.Call.Return(run)
	return _c
}

// SearchWorkingSchedule provides a mock function with given fields: ctx, user, search
func (_m *MockWorkingScheduleManager) SearchWorkingSchedule(ctx context.Context, user *model.SignedInUser, search *model.SearchItem) ([]*model.WorkingSchedule, bool, error) {
	ret := _m.Called(ctx, user, search)

	if len(ret) == 0 {
		panic("no return value specified for SearchWorkingSchedule")
	}

	var r0 []*model.WorkingSchedule
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, *model.SearchItem) ([]*model.WorkingSchedule, bool, error)); ok {
		return rf(ctx, user, search)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, *model.SearchItem) []*model.WorkingSchedule); ok {
		r0 = rf(ctx, user, search)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.WorkingSchedule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.SignedInUser, *model.SearchItem) bool); ok {
		r1 = rf(ctx, user, search)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *model.SignedInUser, *model.SearchItem) error); ok {
		r2 = rf(ctx, user, search)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockWorkingScheduleManager_SearchWorkingSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchWorkingSchedule'
type MockWorkingScheduleManager_SearchWorkingSchedule_Call struct {
	*mock.Call
}

// SearchWorkingSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.SignedInUser
//   - search *model.SearchItem
func (_e *MockWorkingScheduleManager_Expecter) SearchWorkingSchedule(ctx interface{}, user interface{}, search interface{}) *MockWorkingScheduleManager_SearchWorkingSchedule_Call {
	return &MockWorkingScheduleManager_SearchWorkingSchedule_Call{Call: _e.mock.On("SearchWorkingSchedule", ctx, user, search)}
}

func (_c *MockWorkingScheduleManager_SearchWorkingSchedule_Call) Run(run func(ctx context.Context, user *model.SignedInUser, search *model.SearchItem)) *MockWorkingScheduleManager_SearchWorkingSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.SignedInUser), args[2].(*model.SearchItem))
	})
	return _c
}

func (_c *MockWorkingScheduleManager_SearchWorkingSchedule_Call) Return(_a0 []*model.WorkingSchedule, _a1 bool, _a2 error) *MockWorkingScheduleManager_SearchWorkingSchedule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockWorkingScheduleManager_SearchWorkingSchedule_Call) RunAndReturn(run func(context.Context, *model.SignedInUser, *model.SearchItem) ([]*model.WorkingSchedule, bool, error)) *MockWorkingScheduleManager_SearchWorkingSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkingSchedule provides a mock function with given fields: ctx, user, in
func (_m *MockWorkingScheduleManager) UpdateWorkingSchedule(ctx context.Context, user *model.SignedInUser, in *model.WorkingSchedule) (*model.WorkingSchedule, error) {
	ret := _m.Called(ctx, user, in)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkingSchedule")
	}

	var r0 *model.WorkingSchedule
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, *model.WorkingSchedule) (*model.WorkingSchedule, error)); ok {
		return rf(ctx, user, in)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, *model.WorkingSchedule) *model.WorkingSchedule); ok {
		r0 = rf(ctx, user, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.WorkingSchedule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.SignedInUser, *model.WorkingSchedule) error); ok {
		r1 = rf(ctx, user, in)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWorkingScheduleManager_UpdateWorkingSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkingSchedule'
type MockWorkingScheduleManager_UpdateWorkingSchedule_Call struct {
	*mock.Call
}

// UpdateWorkingSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.SignedInUser
//   - in *model.WorkingSchedule
func (_e *MockWorkingScheduleManager_Expecter) UpdateWorkingSchedule(ctx interface{}, user interface{}, in interface{}) *MockWorkingScheduleManager_UpdateWorkingSchedule_Call {
	return &MockWorkingScheduleManager_UpdateWorkingSchedule_Call{Call: _e.mock.On("UpdateWorkingSchedule", ctx, user, in)}
}

func (_c *MockWorkingScheduleManager_UpdateWorkingSchedule_Call) Run(run func(ctx context.Context, user *model.SignedInUser, in *model.WorkingSchedule)) *MockWorkingScheduleManager_UpdateWorkingSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.SignedInUser), args[2].(*model.WorkingSchedule))
	})
	return _c
}

func (_c *MockWorkingScheduleManager_UpdateWorkingSchedule_Call) Return(_a0 *model.WorkingSchedule, _a1 error) *MockWorkingScheduleManager_UpdateWorkingSchedule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWorkingScheduleManager_UpdateWorkingSchedule_Call) RunAndReturn(run func(context.Context, *model.SignedInUser, *model.WorkingSchedule) (*model.WorkingSchedule, error)) *MockWorkingScheduleManager_UpdateWorkingSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkingScheduleAddAgents provides a mock function with given fields: ctx, user, id, agentIds
func (_m *MockWorkingScheduleManager) UpdateWorkingScheduleAddAgents(ctx context.Context, user *model.SignedInUser, id int64, agentIds []int64) ([]*model.LookupItem, error) {
	ret := _m.Called(ctx, user, id, agentIds)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkingScheduleAddAgents")
	}

	var r0 []*model.LookupItem
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, int64, []int64) ([]*model.LookupItem, error)); ok {
		return rf(ctx, user, id, agentIds)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, int64, []int64) []*model.LookupItem); ok {
		r0 = rf(ctx, user, id, agentIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.LookupItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.SignedInUser, int64, []int64) error); ok {
		r1 = rf(ctx, user, id, agentIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWorkingScheduleManager_UpdateWorkingScheduleAddAgents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkingScheduleAddAgents'
type MockWorkingScheduleManager_UpdateWorkingScheduleAddAgents_Call struct {
	*mock.Call
}

// UpdateWorkingScheduleAddAgents is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.SignedInUser
//   - id int64
//   - agentIds []int64
func (_e *MockWorkingScheduleManager_Expecter) UpdateWorkingScheduleAddAgents(ctx interface{}, user interface{}, id interface{}, agentIds interface{}) *MockWorkingScheduleManager_UpdateWorkingScheduleAddAgents_Call {
	return &MockWorkingScheduleManager_UpdateWorkingScheduleAddAgents_Call{Call: _e.mock.On("UpdateWorkingScheduleAddAgents", ctx, user, id, agentIds)}
}

func (_c *MockWorkingScheduleManager_UpdateWorkingScheduleAddAgents_Call) Run(run func(ctx context.Context, user *model.SignedInUser, id int64, agentIds []int64)) *MockWorkingScheduleManager_UpdateWorkingScheduleAddAgents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.SignedInUser), args[2].(int64), args[3].([]int64))
	})
	return _c
}

func (_c *MockWorkingScheduleManager_UpdateWorkingScheduleAddAgents_Call) Return(_a0 []*model.LookupItem, _a1 error) *MockWorkingScheduleManager_UpdateWorkingScheduleAddAgents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWorkingScheduleManager_UpdateWorkingScheduleAddAgents_Call) RunAndReturn(run func(context.Context, *model.SignedInUser, int64, []int64) ([]*model.LookupItem, error)) *MockWorkingScheduleManager_UpdateWorkingScheduleAddAgents_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkingScheduleRemoveAgent provides a mock function with given fields: ctx, user, id, agentId
func (_m *MockWorkingScheduleManager) UpdateWorkingScheduleRemoveAgent(ctx context.Context, user *model.SignedInUser, id int64, agentId int64) (int64, error) {
	ret := _m.Called(ctx, user, id, agentId)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkingScheduleRemoveAgent")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, int64, int64) (int64, error)); ok {
		return rf(ctx, user, id, agentId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.SignedInUser, int64, int64) int64); ok {
		r0 = rf(ctx, user, id, agentId)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.SignedInUser, int64, int64) error); ok {
		r1 = rf(ctx, user, id, agentId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWorkingScheduleManager_UpdateWorkingScheduleRemoveAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkingScheduleRemoveAgent'
type MockWorkingScheduleManager_UpdateWorkingScheduleRemoveAgent_Call struct {
	*mock.Call
}

// UpdateWorkingScheduleRemoveAgent is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.SignedInUser
//   - id int64
//   - agentId int64
func (_e *MockWorkingScheduleManager_Expecter) UpdateWorkingScheduleRemoveAgent(ctx interface{}, user interface{}, id interface{}, agentId interface{}) *MockWorkingScheduleManager_UpdateWorkingScheduleRemoveAgent_Call {
	return &MockWorkingScheduleManager_UpdateWorkingScheduleRemoveAgent_Call{Call: _e.mock.On("UpdateWorkingScheduleRemoveAgent", ctx, user, id, agentId)}
}

func (_c *MockWorkingScheduleManager_UpdateWorkingScheduleRemoveAgent_Call) Run(run func(ctx context.Context, user *model.SignedInUser, id int64, agentId int64)) *MockWorkingScheduleManager_UpdateWorkingScheduleRemoveAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.SignedInUser), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockWorkingScheduleManager_UpdateWorkingScheduleRemoveAgent_Call) Return(_a0 int64, _a1 error) *MockWorkingScheduleManager_UpdateWorkingScheduleRemoveAgent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWorkingScheduleManager_UpdateWorkingScheduleRemoveAgent_Call) RunAndReturn(run func(context.Context, *model.SignedInUser, int64, int64) (int64, error)) *MockWorkingScheduleManager_UpdateWorkingScheduleRemoveAgent_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWorkingScheduleManager creates a new instance of MockWorkingScheduleManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWorkingScheduleManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWorkingScheduleManager {
	mock := &MockWorkingScheduleManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
